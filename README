Принцип работы бэкенда WhatClient

Бэкенд WhatClient — это сервис-посредник, который позволяет пользователям плагина анонимно запрашивать информацию о Telegram-клиенте друг друга. Архитектура построена на FastAPI и использует временные сессии для обмена данными, не храня постоянно никакой информации о пользователях.

Основная логика

Процесс полностью зависит от того, что у обоих пользователей (запрашивающего и того, чью информацию запрашивают) установлен и активен плагин.

1.  Запрос информации (Алиса -> Сервер)
    *   Пользователь Алиса вводит команду `.wc [ID Боба]`.
    *   Плагин Алисы отправляет на сервер запрос (`POST /requestClient`), содержащий её ID и ID Боба.
    *   Сервер создает "задачу на проверку" с уникальным `request_id` и сохраняет её во временном хранилище, ожидая ответа от клиента Боба.

2.  Опрос и ответ (Боб -> Сервер)
    *   Плагин Боба периодически (в фоновом режиме) опрашивает сервер (`GET /getTasks/{user_id}`), есть ли для него активные задачи.
    *   Обнаружив запрос от Алисы, плагин Боба выполняет локальную проверку, получает имя своего пакета (`package_name`) и отправляет его на сервер (`POST /submitTaskResult`) в качестве ответа на задачу.

3.  Получение результата (Алиса -> Сервер)
    *   Плагин Алисы, после отправки первоначального запроса, начинает опрашивать сервер (`GET /getRequestResult/{request_id}`) о статусе своей задачи.
    *   Как только сервер получает ответ от Боба, он помечает задачу как выполненную и сохраняет **зашифрованный** результат (имя клиента Боба).
    *   При следующем опросе плагин Алисы получает **расшифрованный** результат и отображает его в виде уведомления.

Ключевые особенности

*   Анонимность и безопасность: Сервер не хранит историю запросов или личные данные. Все сессии и задачи являются временными (удаляются через несколько минут).
*   Шифрование "в состоянии покоя" (At-Rest Encryption): Данные, временно хранящиеся на сервере (например, имя клиента), шифруются с помощью **эфемерного ключа**. Этот ключ генерируется при каждом запуске сервера и удаляется при его остановке. Это означает, что даже если кто-то получит доступ к памяти работающего приложения, он не сможет прочитать исходные данные. После перезапуска сервера старые данные становятся невосстановимыми.
*   Работа в моменте: Определение клиента возможно только если оба пользователя онлайн и у них активен плагин.
*   Отсутствие прямого P2P-соединения: Всё взаимодействие происходит через центральный сервер, который выступает в роли безопасного посредника.

===== Безопасность =====

Все запросы к API должны быть подписаны с использованием HMAC-SHA256. Это гарантирует, что только авторизованные клиенты (плагины) могут взаимодействовать с сервером.

1. HMAC-подпись

Как это работает:

1.  Секретный ключ: На сервере и в каждом плагине должен быть один и тот же `API_SECRET_KEY`. На сервере он устанавливается через переменную окружения.
2.  Заголовок `X-Signature`: Каждый запрос должен содержать этот заголовок с HMAC-подписью.
3.  Генерация подписи:
    *   Для `POST` запросов подписывается **тело запроса (raw body)**.
    *   Для `GET` запросов подписывается **путь запроса** (например, `/getTasks/12345`).

Пример генерации подписи на Python

import hmac
import hashlib

API_SECRET_KEY = "ваш_секретный_ключ".encode('utf-8')

# Для POST-запроса
post_body = '{"requester_id": 123, "target_id": 456}'.encode('utf-8')
post_signature = hmac.new(API_SECRET_KEY, post_body, hashlib.sha256).hexdigest()
# headers = {"X-Signature": post_signature}

# Для GET-запроса
get_path = "/getTasks/456".encode('utf-8')
get_signature = hmac.new(API_SECRET_KEY, get_path, hashlib.sha256).hexdigest()
# headers = {"X-Signature": get_signature}

2. Эфемерное шифрование

В дополнение к HMAC-подписям, все чувствительные данные, которые временно хранятся в памяти сервера, шифруются с использованием простого XOR-шифра и эфемерного ключа (`EPHEMERAL_KEY`), генерируемого при запуске. Это защищает данные "в состоянии покоя".

*   **Ключ**: Генерируется с помощью `os.urandom(32)` при старте `main.py`.
*   **Шифрование**: Результат, полученный от клиента (`client_name`), шифруется функцией `encrypt_data` перед сохранением в `PENDING_REQUESTS`.
*   **Дешифрование**: Зашифрованный результат расшифровывается функцией `decrypt_data` непосредственно перед отправкой запрашивающему клиенту.

===== Тестирование безопасности =====

В директории `security/` находятся скрипты для проверки основных аспектов безопасности API.

*   `test_signature.py`: Тестирует эндпоинты с корректными и некорректными HMAC-подписями.
*   `test_full_flow.py`: Симулирует полный цикл взаимодействия между двумя клиентами через бэкенд для проверки корректности работы всей логики.

Для запуска тестов установите зависимости и запустите скрипты из корневой папки бэкенда.
